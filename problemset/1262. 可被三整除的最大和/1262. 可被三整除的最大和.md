#### [1262. 可被三整除的最大和](https://leetcode.cn/problems/greatest-sum-divisible-by-three/)

难度中等

给你一个整数数组 `nums`，请你找出并返回能被三整除的元素最大和。

**示例 1：**

**输入：**nums = [3,6,5,1,8]
**输出：**18
**解释：**选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。

**示例 2：**

**输入：**nums = [4]
**输出：**0
**解释：**4 不能被 3 整除，所以无法选出数字，返回 0。

**示例 3：**

**输入：**nums = [1,2,3,4,4]
**输出：**12
**解释：**选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。

**提示：**

- `1 <= nums.length <= 4 * 10^4`
- `1 <= nums[i] <= 10^4`

本题的目标是找到一个子集，其元素之和可以被3整除，并且这个和是最大的。解决这个问题的关键在于理解如果一个数字之和能被3整除，那么它与3的余数必然为0。如果余数不为0，那么我们需要从这个和中减去一些数字使得新的和与3的余数为0。显然，我们应该优先减去最小的数字。

我们可以遍历数组并计算所有数字的总和。然后我们将遇到的数字按照它们与3的余数进行分类。余数为1和余数为2的数我们都只需要最小的两个（因为两个余数为1的数或者一个余数为1的数和一个余数为2的数的和都能被3整除）。

如果总和与3的余数为0，那么答案就是总和。如果余数为1，我们可以选择减去一个余数为1的数字或者两个余数为2的数字。如果余数为2，我们可以选择减去一个余数为2的数字或者两个余数为1的数字。在每种情况下，我们都应该选择减去的数字之和最小。如果不存在足够的数字可以减去，那么我们可以忽略这种情况。

下面是这个思路的Python代码实现：

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        remainder_1 = [10001] * 2
        remainder_2 = [10001] * 2
        total = 0

        for num in nums:
            total += num
            if num % 3 == 1:
                remainder_1 = sorted(remainder_1 + [num])[:2]
            if num % 3 == 2:
                remainder_2 = sorted(remainder_2 + [num])[:2]

        if total % 3 == 0:
            return total
        elif total % 3 == 1:
            return total - min(remainder_1[0], sum(remainder_2) if sum(remainder_2) != 20002 else float('inf'))
        else:
            return total - min(remainder_2[0], sum(remainder_1) if sum(remainder_1) != 20002 else float('inf'))
```

这个代码首先初始化了两个列表remainder_1和remainder_2，用于存储余数为1和余数为2的最小的两个数。我们使用一个大数（10001）来初始化这些列表，因为题目中说明每个数都在1和10000之间。

然后代码遍历数组并计算总和，同时更新余数列表。我们使用sorted函数和列表切片来保持列表按照大小排序并且只包含最小的两个元素。

最后，根据总和与3的余数，我们返回相应的结果。注意我们需要检查在尝试减去两个数的时候，是否存在足够的数字。这通过检查两个数的和是否为初始化的大数的两倍（20002）来实现。

---

动态规划是另一种解决这个问题的有效方法，具有更优的时间复杂度。

一个数组中的元素之和能被3整除，只有三种可能：和对3取余等于0，等于1，或者等于2。可以创建一个dp数组，dp[i]表示数组和模3余i的情况下，能达到的最大和。

遍历输入数组，每次遍历到一个新元素，都会有新的和产生。这些和对3取余，只可能为0，1，2三种情况，然后更新dp数组对应位置的值。值得注意的是，更新dp数组的时候需要从大到小更新，这样才能保证dp数组中的值在同一轮中只被更新一次。

```python
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        dp = [0, 0, 0]
        for num in nums:
            a, b, c = dp
            for sum_ in [a + num, b + num, c + num]:
                dp[sum_ % 3] = max(dp[sum_ % 3], sum_)
        return dp[0]
```

这种方法的时间复杂度是O(n)，其中n是输入数组的长度。这是因为我们只需要遍历一次输入数组，同时更新dp数组的时间复杂度是常数。这比前一种方法中需要排序和切片的操作更高效。