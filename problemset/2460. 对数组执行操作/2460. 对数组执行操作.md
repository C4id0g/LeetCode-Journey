#### [2460. 对数组执行操作](https://leetcode.cn/problems/apply-operations-to-an-array/)

难度简单

给你一个下标从 **0** 开始的数组 `nums` ，数组大小为 `n` ，且由 **非负** 整数组成。

你需要对数组执行 `n - 1` 步操作，其中第 `i` 步操作（从 **0** 开始计数）要求对 `nums` 中第 `i` 个元素执行下述指令：

- 如果 `nums[i] == nums[i + 1]` ，则 `nums[i]` 的值变成原来的 `2` 倍，`nums[i + 1]` 的值变成 `0` 。否则，跳过这步操作。

在执行完 **全部** 操作后，将所有 `0` **移动** 到数组的 **末尾** 。

- 例如，数组 `[1,0,2,0,0,1]` 将所有 `0` 移动到末尾后变为 `[1,2,1,0,0,0]` 。

返回结果数组。

**注意** 操作应当 **依次有序** 执行，而不是一次性全部执行。

**示例 1：**

**输入：**nums = [1,2,2,1,1,0]
**输出：**[1,4,2,0,0,0]
**解释：**执行以下操作：

- i = 0: nums[0] 和 nums[1] 不相等，跳过这步操作。
- i = 1: nums[1] 和 nums[2] 相等，nums[1] 的值变成原来的 2 倍，nums[2] 的值变成 0 。数组变成 [1,***4***,***0***,1,1,0] 。
- i = 2: nums[2] 和 nums[3] 不相等，所以跳过这步操作。
- i = 3: nums[3] 和 nums[4] 相等，nums[3] 的值变成原来的 2 倍，nums[4] 的值变成 0 。数组变成 [1,4,0,***2***,***0***,0] 。
- i = 4: nums[4] 和 nums[5] 相等，nums[4] 的值变成原来的 2 倍，nums[5] 的值变成 0 。数组变成 [1,4,0,2,***0***,***0***] 。
  执行完所有操作后，将 0 全部移动到数组末尾，得到结果数组 [1,4,2,0,0,0] 。

**示例 2：**

**输入：**nums = [0,1]
**输出：**[1,0]
**解释：**无法执行任何操作，只需要将 0 移动到末尾。

**提示：**

- `2 <= nums.length <= 2000`
- `0 <= nums[i] <= 1000`

这个问题可以使用一个简单的线性扫描来解决。我们按照操作的规则依次检查数组中的每个元素，如果`nums[i] == nums[i + 1]`，则将`nums[i]`的值变成原来的2倍，`nums[i + 1]`的值变成0。然后我们将所有的0移动到数组的末尾。

在Python中，我们可以通过列表推导式将所有的0移动到数组的末尾。先创建一个新的列表，其中包含所有非零的元素，然后添加相同数量的0。

下面是代码实现：

```python
class Solution(object):
    def applyOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        # 执行n-1步操作
        for i in range(len(nums) - 1):
            # 如果当前元素和下一个元素相等
            if nums[i] == nums[i + 1]:
                # 当前元素变为原来的2倍
                nums[i] *= 2
                # 下一个元素变为0
                nums[i + 1] = 0

        # 将所有的0移动到数组的末尾
        nums = [x for x in nums if x != 0] + [0] * nums.count(0)

        return nums
```

注意：由于对列表进行的是原地修改操作，因此在移动0到数组末尾的时候需要创建一个新的列表，否则可能会导致结果不正确。在Python中，`list.count(x)`方法用于统计某个元素在列表中出现的次数，我们使用这个方法来统计0的数量，以便在末尾添加相应数量的0。

---

在上面的解决方案中，我们遍历了列表两次，一次用于操作，一次用于计数。实际上，我们可以在一次遍历中完成操作并记住零的个数，然后直接在数组末尾添加零，这样可以减少一次遍历，优化时间复杂度。

我们可以使用双指针技术，一个指针 `i` 用于遍历数组，另一个指针 `j` 用于指示下一个非零元素应该放在哪里。

这是优化后的解决方案：

```python
class Solution(object):
    def applyOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        j = 0
        zeros = 0

        # 执行n-1步操作
        for i in range(len(nums) - 1):
            # 如果当前元素和下一个元素相等
            if nums[i] == nums[i + 1]:
                # 当前元素变为原来的2倍
                nums[i] *= 2
                # 下一个元素变为0
                nums[i + 1] = 0
                zeros += 1

            # 如果当前元素不为零，则将其移动到 j 的位置
            if nums[i] != 0:
                nums[j] = nums[i]
                j += 1

        # 处理最后一个元素
        if nums[-1] != 0:
            nums[j] = nums[-1]
            j += 1

        # 将所有的0移动到数组的末尾
        for i in range(j, len(nums)):
            nums[i] = 0

        return nums
```

在这个解决方案中，我们首先遍历数组，并在执行操作的同时计算零的数量。然后我们用第二个指针 `j` 跟踪数组中的非零元素，并将非零元素移到 `j` 的位置。最后，我们在数组末尾添加相同数量的零。

注意：这种解决方案仍然需要在数组的长度范大时处理大量的零。如果输入数组中的零非常多，可能会导致内存使用不够高效。因此，对于非常大的数组，可能需要寻找其他的优化策略，比如使用更加高效的数据结构来处理大量的零。