#### [1851. 包含每个查询的最小区间](https://leetcode.cn/problems/minimum-interval-to-include-each-query/)

难度困难

给你一个二维整数数组 `intervals` ，其中 `intervals[i] = [lefti, righti]` 表示第 `i` 个区间开始于 `lefti` 、结束于 `righti`（包含两侧取值，**闭区间**）。区间的 **长度** 定义为区间中包含的整数数目，更正式地表达是 `righti - lefti + 1` 。

再给你一个整数数组 `queries` 。第 `j` 个查询的答案是满足 `lefti <= queries[j] <= righti` 的 **长度最小区间 `i` 的长度** 。如果不存在这样的区间，那么答案是 `-1` 。

以数组形式返回对应查询的所有答案。

**示例 1：**

**输入：**intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]
**输出：**[3,3,1,4]
**解释：**查询处理如下：

- Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。
- Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。
- Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。
- Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。

**示例 2：**

**输入：**intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]
**输出：**[2,-1,4,6]
**解释：**查询处理如下：

- Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。
- Query = 19：不存在包含 19 的区间，答案为 -1 。
- Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。
- Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。

**提示：**

- `1 <= intervals.length <= 105`
- `1 <= queries.length <= 105`
- `queries[i].length == 2`
- `1 <= lefti <= righti <= 107`
- `1 <= queries[j] <= 107`

这是一道复杂的问题，需要合理地组织和处理数据。基于题目的提示，我们可以考虑以下的步骤：

1. **离线查询**：我们可以将查询按照从小到大的顺序进行排序，然后依次处理。这样可以避免对每个查询都进行一次全面的搜索，从而提高效率。
  
2. **优先队列**：我们可以将区间按照长度的从小到大的顺序放入优先队列中，这样就可以快速地找到长度最小的区间。
  
3. **延迟删除**：当我们处理到一个查询时，队列中可能存在一些无法包含该查询的区间。这些区间在之后的查询中也不可能被用到，因此我们可以将它们从队列中删除。为了避免频繁地删除操作，我们可以使用延迟删除的策略，即在每次需要查询最小区间时，先删除队列顶部所有无法使用的区间，然后再返回最小区间。
  

基于以上的分析，我们可以得到如下的算法：

1. 将所有的查询和区间分别按照从小到大的顺序进行排序。
  
2. 创建一个空的优先队列，用于存储区间。队列中的元素是一个二元组，分别表示区间的右端点和长度，按照长度的从小到大的顺序进行排序。
  
3. 对于每一个查询，将所有可以包含该查询的区间放入优先队列中，然后将队列顶部所有无法使用的区间删除，最后返回队列顶部的区间长度。如果队列为空，则返回-1。
  

现在我们来实现这个算法。由于 Python 的标准库中没有实现优先队列，所以我们需要使用 `heapq` 模块来实现优先队列。在 `heapq` 模块中，小的元素会被放在队列的前面，所以我们可以直接使用二元组的默认比较方式（首先比较第一个元素，如果相等则比较第二个元素）。由于我们需要按照长度的从小到大的顺序进行排序，所以在放入队列时，我们将长度放在二元组的第一个元素。

首先，我们需要将区间和查询按照从小到大的顺序进行排序。对于区间，我们可以先按照左端点进行排序，如果左端点相同，则按照右端点进行排序。对于查询，我们不仅需要排序，还需要保留原来的顺序，以便最后能将结果放回原来的位置。所以我们可以将查询和它的原始索引一起放入一个列表，然后按照查询的大小进行排序。

接下来，我们可以创建一个空的优先队列，然后开始处理查询。每处理一个查询，我们就将所有可以包含该查询的区间放入优先队列中，然后删除队列顶部所有无法使用的区间，最后将队列顶部的区间长度放入结果数组中。

最后，我们将结果数组按照原始的顺序进行排序，然后返回结果。

下面是这个算法的 Python 代码实现：

```python
from typing import List
import heapq

class Solution:
    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:
        # 将区间按照左端点从小到大、右端点从大到小的顺序进行排序
        intervals.sort(key=lambda x: (x[0], -x[1]))
        
        # 将查询和它的原始索引一起放入一个列表，然后按照查询的大小进行排序
        queries = sorted((q, i) for i, q in enumerate(queries))
        
        # 创建一个空的优先队列，用于存储区间
        queue = []
        
        # 初始化结果数组
        res = [0] * len(queries)
        
        # 初始化区间的指针
        i = 0
        
        # 对每一个查询，将所有可以包含该查询的区间放入优先队列中，然后将队列顶部所有无法使用的区间删除，
        # 最后将队列顶部的区间长度放入结果数组中
        for q, j in queries:
            while i < len(intervals) and intervals[i][0] <= q:
                l, r = intervals[i]
                heapq.heappush(queue, (r - l + 1, r))
                i += 1
            while queue and queue[0][1] < q:
                heapq.heappop(queue)
            res[j] = queue[0][0] if queue else -1
        
        return res

```