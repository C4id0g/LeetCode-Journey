#### [1375. 二进制字符串前缀一致的次数](https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned/)

难度中等

给你一个长度为 `n` 、下标从 **1** 开始的二进制字符串，所有位最开始都是 `0` 。我们会按步翻转该二进制字符串的所有位（即，将 `0` 变为 `1`）。

给你一个下标从 **1** 开始的整数数组 `flips` ，其中 `flips[i]` 表示对应下标 `i` 的位将会在第 `i` 步翻转。

二进制字符串 **前缀一致** 需满足：在第 `i` 步之后，在 **闭** 区间 `[1, i]` 内的所有位都是 1 ，而其他位都是 0 。

返回二进制字符串在翻转过程中 **前缀一致** 的次数。

**示例 1：**

**输入：**flips = [3,2,4,1,5]
**输出：**2
**解释：**二进制字符串最开始是 "00000" 。
执行第 1 步：字符串变为 "00100" ，不属于前缀一致的情况。
执行第 2 步：字符串变为 "01100" ，不属于前缀一致的情况。
执行第 3 步：字符串变为 "01110" ，不属于前缀一致的情况。
执行第 4 步：字符串变为 "11110" ，属于前缀一致的情况。
执行第 5 步：字符串变为 "11111" ，属于前缀一致的情况。
在翻转过程中，前缀一致的次数为 2 ，所以返回 2 。

**示例 2：**

**输入：**flips = [4,1,2,3]
**输出：**1
**解释：**二进制字符串最开始是 "0000" 。
执行第 1 步：字符串变为 "0001" ，不属于前缀一致的情况。
执行第 2 步：字符串变为 "1001" ，不属于前缀一致的情况。
执行第 3 步：字符串变为 "1101" ，不属于前缀一致的情况。
执行第 4 步：字符串变为 "1111" ，属于前缀一致的情况。
在翻转过程中，前缀一致的次数为 1 ，所以返回 1 。

**提示：**

- `n == flips.length`
- `1 <= n <= 5 * 104`
- `flips` 是范围 `[1, n]` 中所有整数构成的一个排列

在这个问题中，我们需要统计翻转二进制字符串过程中，字符串在前i步的前缀都是'1'，其他位都是'0'的次数。换句话说，当且仅当翻转位的位置小于等于当前步骤数且是目前已翻转位置的最大值时，我们就找到了一个前缀一致的情况。那么我们可以遍历每一步，检查每一步翻转的位置是否满足这个条件。

下面是Python代码实现：

```python
class Solution:
    def numTimesAllBlue(self, flips: List[int]) -> int:
        maxFlip = 0
        prefixCount = 0
        for i, flip in enumerate(flips, 1):
            maxFlip = max(maxFlip, flip)
            if maxFlip == i:
                prefixCount += 1
        return prefixCount
```

在这段代码中，我们首先初始化最大翻转位置`maxFlip`为0和前缀一致次数`prefixCount`为0。然后，我们遍历`flips`列表，同时更新`maxFlip`和检查当前步骤是否满足前缀一致的条件。如果满足，我们就增加`prefixCount`。最后，我们返回`prefixCount`作为结果。

这段代码的时间复杂度是O(n)，其中n是`flips`列表的长度，因为我们只需要遍历一次`flips`列表。空间复杂度是O(1)，因为我们只需要常数的额外空间来存储`maxFlip`和`prefixCount`。