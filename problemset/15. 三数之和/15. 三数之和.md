#### [15. 三数之和](https://leetcode.cn/problems/3sum/)

难度中等

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请
你返回所有和为 `0` 且不重复的三元组。
**注意：**答案中不可以包含重复的三元组。
**示例 1：**
**输入：**nums = [-1,0,1,2,-1,-4]
**输出：**[[-1,-1,2],[-1,0,1]]
**解释：**
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
**示例 2：**
**输入：**nums = [0,1,1]
**输出：**[]
**解释：**唯一可能的三元组和不为 0 。
**示例 3：**
**输入：**nums = [0,0,0]
**输出：**[[0,0,0]]
**解释：**唯一可能的三元组和为 0 。
**提示：**

- `3 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

这是一道经典的数组处理问题，可以通过双指针的方式进行解决。以下是解题思路：

1. 首先，我们对数组进行排序，这样就可以在接下来的遍历中，通过移动指针来改变和的大小。
  
2. 接下来，我们遍历排序后的数组，对于每一个元素，我们尝试找两个和为该元素的相反数的元素。
  
3. 我们在这个元素之后的数组中，设定两个指针，一个指向头部，一个指向尾部。如果这两个元素的和大于我们要找的数，那么我们将尾部的指针向前移动，使得和减小。同理，如果这两个元素的和小于我们要找的数，那么我们将头部的指针向后移动，使得和增大。
  
4. 如果找到了这样的两个元素，我们就找到了一个结果，将它加入结果列表。
  
5. 需要注意的是，为了避免重复的结果，我们需要跳过相同的元素。
  

下面是这个算法的 Python 实现：

```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        res = []
        for i in range(len(nums) - 2):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l, r = i + 1, len(nums) - 1
            while l < r:
                s = nums[i] + nums[l] + nums[r]
                if s < 0:
                    l += 1
                elif s > 0:
                    r -= 1
                else:
                    res.append((nums[i], nums[l], nums[r]))
                    while l < r and nums[l] == nums[l + 1]:
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
        return res
```

这个算法的时间复杂度为 O(n^2)，其中 n 是数组的长度。因为我们需要遍历数组，然后在每次遍历的过程中，都需要进行一次双指针扫描，双指针扫描的时间复杂度为 O(n)。