#### [7. 整数反转](https://leetcode.cn/problems/reverse-integer/)

难度中等

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 `[−231,  231 − 1]` ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

**示例 1：**

**输入：**x = 123
**输出：**321

**示例 2：**

**输入：**x = -123
**输出：**-321

**示例 3：**

**输入：**x = 120
**输出：**21

**示例 4：**

**输入：**x = 0
**输出：**0

**提示：**

- `-231 <= x <= 231 - 1`

- 我们要反转一个整数，就是将它的每一位数字倒过来，比如 123 反转后就是 321，-123 反转后就是 -321。
- 但是，我们要注意两个问题：一是 x 的符号，二是反转后的结果是否在范围内。
- x 的符号会影响我们如何处理每一位数字，因为负数的最后一位数字其实是符号位，比如 -123 的最后一位数字是 -3，而不是 3。所以，我们要先把 x 的符号保存下来，然后将 x 转换为正数，这样就可以按照正数的方式来反转每一位数字了。
- 反转后的结果是否在范围内，这是因为题目给定了一个 32 位的有符号整数的范围，也就是 [-2^31, 2^31 - 1]。如果反转后的结果超出了这个范围，就要返回 0。所以，我们要在反转后检查一下结果是否在范围内，如果不在，就返回 0，否则就返回结果。

```python
class Solution:
    def reverse(self, x: int) -> int:
        # 定义一个变量存储反转后的结果
        result = 0
        # 定义一个变量存储 x 的符号，1 表示正数，-1 表示负数
        sign = 1 if x >= 0 else -1
        # 将 x 转换为正数，方便处理
        x = abs(x)
        # 循环反转 x 的每一位数字
        while x > 0:
            # 取出 x 的最后一位数字，加到 result 的末尾
            result = result * 10 + x % 10
            # 去掉 x 的最后一位数字
            x = x // 10
        # 恢复 x 的符号，并检查结果是否在范围内
        result = sign * result
        if result < -2**31 or result > 2**31 - 1:
            return 0
        else:
            return result
```

这个代码的逻辑是这样的：

- 首先，我们定义一个变量 result 来存储反转后的结果，初始值为 0。
- 然后，我们定义一个变量 sign 来存储 x 的符号，如果 x 是正数，就让 sign 为 1，如果 x 是负数，就让 sign 为 -1。
- 接着，我们将 x 转换为正数，这样方便我们处理每一位数字。我们可以用绝对值函数 abs(x) 来实现这一步。
- 然后，我们用一个循环来反转 x 的每一位数字。循环的条件是 x 大于 0，也就是说，当 x 变成 0 时，就说明已经反转完了。
- 在循环中，我们先取出 x 的最后一位数字，也就是 x 对 10 取余的结果。然后，我们将这个数字加到 result 的末尾，也就是 result 乘以 10 再加上这个数字。这样，result 就反转了一位数字。
- 然后，我们将 x 去掉最后一位数字，也就是 x 除以 10 取整的结果。这样，x 就减少了一位数字。
- 循环结束后，我们就得到了反转后的结果 result。但是，我们还需要恢复 x 的符号，并检查 result 是否在范围内。
- 我们可以用 sign 乘以 result 来恢复 x 的符号。然后，我们判断 result 是否小于 -2^31 或者大于 2^31 - 1，如果是的话，就返回 0，否则就返回 result。

**优化：**

```python
class Solution:
    def reverse(self, x: int) -> int:
        INT_MAX = 2_147_483_647  # 2**31 - 1
        INT_MIN = -2_147_483_648  # -2**31
        
        result, sign = 0, 1
        
        if x < 0:
            sign = -1
            x = abs(x)
        
        while x:
            x, digit = divmod(x, 10)
            result = result * 10 + digit
            if result > INT_MAX or result < INT_MIN:
                return 0
        
        return sign * result

```

1. 使用单独的行对 `result` 和 `sign` 进行初始化，增强代码的可读性。
2. 将符号判断移动到循环之前，减少不必要的符号判断次数。
3. 在循环内部添加了边界检查，如果 `result` 超出整数范围，则直接返回 0。
4. 通过直接返回 `sign * result`，避免在最后对 `result` 进行符号恢复的操作。