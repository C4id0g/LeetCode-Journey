#### [1091. 二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/)

难度中等


给你一个 `n x n` 的二进制矩阵 `grid` 中，返回矩阵中最短 **畅通路径** 的长度。如果不存在这样的路径，返回 `-1` 。

二进制矩阵中的 畅通路径 是一条从 **左上角** 单元格（即，`(0, 0)`）到 右下角 单元格（即，`(n - 1, n - 1)`）的路径，该路径同时满足下述要求：

- 路径途经的所有单元格都的值都是 `0` 。
- 路径中所有相邻的单元格应当在 **8 个方向之一** 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。

**畅通路径的长度** 是该路径途经的单元格总数。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/18/example1_1.png)

**输入：**grid = [[0,1],[1,0]]
**输出：**2

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/02/18/example2_1.png)

**输入：**grid = [[0,0,0],[1,1,0],[1,1,0]]
**输出：**4

**示例 3：**

**输入：**grid = [[1,0,0],[1,1,0],[1,1,0]]
**输出：**-1

**提示：**

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 100`
- `grid[i][j]` 为 `0` 或 `1`

这是一个经典的图搜索问题，可以使用广度优先搜索（BFS）来解决。BFS是一种适合找到最短路径问题的算法。在二维网格中，我们可以将每个单元格看作一个节点，相邻的单元格为相邻的节点，这样整个网格就成为一个图。

在这个问题中，每次移动都可以在8个方向上进行，所以在BFS中，每个节点有8个邻居。

此外，因为路径的长度是途经的单元格的总数，所以我们可以在BFS的过程中记录下到达每个节点的最小步数。

Python的解决方案如下：

```python
# 从collections模块中导入deque类，它提供了双端队列的功能。
from collections import deque
from typing import List

# 定义一个名为Solution的类
class Solution:
    # 类中定义一个函数：shortestPathBinaryMatrix，它的参数是一个类型为二维整数列表的网格。
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        # 获取网格的边长
        n = len(grid)
        # 如果网格的起点(0,0)或者终点(n-1,n-1)是阻塞的（值为1），那么返回-1，表示无法到达。
        if grid[0][0] or grid[n-1][n-1]:
            return -1

        # 创建一个双端队列q，并初始化为从(0,0)开始，距离为1的元组。
        q = deque([(0, 0, 1)]) 
        # 标记网格的起点(0,0)为已访问
        grid[0][0] = 1 

        # 定义八个方向（上，下，左，右，以及四个对角线方向）
        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

        # 当队列不为空时
        while q:
            # 从队列中取出一个元素，i和j表示当前位置，dist表示从起点到当前位置的距离
            i, j, dist = q.popleft()
            # 如果当前位置是终点(n-1,n-1)，则返回当前距离，即为最短路径。
            if i == j == n - 1:
                return dist
            # 否则，考虑从当前位置出发，向8个可能的方向前进。
            for dx, dy in directions:
                # 计算前进后的新位置
                x, y = i + dx, j + dy
                # 如果新位置在网格内，并且未被访问（值为0），则标记为已访问，并加入队列。
                if 0 <= x < n and 0 <= y < n and not grid[x][y]:
                    grid[x][y] = 1 # 标记为已访问
                    q.append((x, y, dist + 1))

        # 如果队列为空，说明所有可达位置都已考虑过，仍然没有找到到达终点的路径，返回-1。
        return -1
```

上述代码首先检查起点和终点是否为0，如果它们中任何一个为1，即被阻止，则返回-1。然后，使用一个队列 `q` 来执行 BFS，队列中的每个元素表示当前位置和从起点到当前位置的距离。然后，对于队列中的每个位置，我们都会尝试向8个方向移动，如果新位置在网格内并且没有被阻止，我们就将其添加到队列中，并将其标记为已访问。我们重复这个过程，直到找到目标位置，或者队列为空，表示没有可行的路径。如果找到目标位置，我们就返回到达目标位置的距离，否则我们返回-1。