#### [979. 在二叉树中分配硬币](https://leetcode.cn/problems/distribute-coins-in-binary-tree/)

难度中等

445

给定一个有 `N` 个结点的二叉树的根结点 `root`，树中的每个结点上都对应有 `node.val` 枚硬币，并且总共有 `N` 枚硬币。

在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。

返回使每个结点上只有一枚硬币所需的移动次数。

**示例 1：**

****

**输入：**[3,0,0]
**输出：**2
**解释：**从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。

**示例 2：**

****

**输入：**[0,3,0]
**输出：**3
**解释：**从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。

**示例 3：**

****

**输入：**[1,0,2]
**输出：**2

**示例 4：**

****

**输入：**[1,0,0,null,3]
**输出：**4

**提示：**

1. `1<= N <= 100`
2. `0 <= node.val <= N`

这个问题是一个二叉树的后序遍历问题，我们可以递归地解决它。在每个节点上，我们都需要传递两个信息：

1. `excess`：表示该节点的硬币数量与1的差值，即这个节点需要多少硬币或者有多少硬币需要移走。
2. `moves`：表示到目前为止需要进行的移动次数。

我们使用深度优先搜索遍历每个节点，当我们访问一个节点时，我们首先遍历其左子节点和右子节点。根据它们的`excess`值，我们可以知道这个节点需要接收多少硬币或者需要给出多少硬币，并更新`moves`的值。

具体的，对于一个节点，我们首先计算它的左右子节点的`excess`和`moves`，然后更新当前节点的`excess`和`moves`。`excess`是当前节点的值加上左右子节点的`excess`减去1，`moves`是左右子节点的`moves`加上左右子节点的`excess`的绝对值（这表示我们需要移动的硬币数量）。

这是解决这个问题的Python代码实现：

```python
class Solution:
    def distributeCoins(self, root):
        self.res = 0
        def dfs(node):
            if not node:
                return 0
            L, R = dfs(node.left), dfs(node.right)
            self.res += abs(L) + abs(R)
            return node.val + L + R - 1

        dfs(root)
        return self.res
```

函数`dfs(node)`返回节点`node`需要的硬币数目，如果为负则表示多余的硬币数目，我们把`abs(L) + abs(R)`加到结果`self.res`中，表示需要移动的硬币次数。最后返回该节点最后剩余的硬币数目。