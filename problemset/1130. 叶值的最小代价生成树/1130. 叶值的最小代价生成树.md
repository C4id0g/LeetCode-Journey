#### [1130. 叶值的最小代价生成树](https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values/)

难度中等

给你一个正整数数组 `arr`，考虑所有满足以下条件的二叉树：

- 每个节点都有 `0` 个或是 `2` 个子节点。
- 数组 `arr` 中的值与树的中序遍历中每个叶节点的值一一对应。
- 每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。

在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。

如果一个节点有 0 个子节点，那么该节点为叶节点。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/08/10/tree1.jpg)

**输入：**arr = [6,2,4]
**输出：**32
**解释：**有两种可能的树，第一种的非叶节点的总和为 36 ，第二种非叶节点的总和为 32 。

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/08/10/tree2.jpg)

**输入：**arr = [4,11]
**输出：**44

**提示：**

- `2 <= arr.length <= 40`
- `1 <= arr[i] <= 15`
- 答案保证是一个 32 位带符号整数，即小于 `231` 。

这是一个动态规划问题，我们需要找出非叶节点的最小可能总和。

首先我们可以用dp[i][j]来表示子数组arr[i...j]所构成的树中所有非叶节点的最小总和。那么我们需要找出所有可能的树，比较每一种情况下的非叶节点总和，取最小值。

对于每一个区间，我们可以选择任何一个位置作为根节点，然后将区间分为两部分，这两部分可以分别形成左子树和右子树。我们需要遍历所有可能的分割位置，将非叶节点总和的最小值更新到dp[i][j]。

我们也需要一个max_arr[i][j]来保存子数组arr[i...j]中的最大值，因为非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。

我们的状态转移方程就是：

dp[i][j] = min(dp[i][k] + dp[k+1][j] + max_arr[i][k]*max_arr[k+1][j] for k in range(i, j))

对于每一个区间，我们需要分别计算出其左右子树的最小代价，然后加上左右子树的最大叶子节点的乘积。这个乘积就是当前这个非叶节点的值。

在实现的时候，我们需要先用动态规划计算出max_arr，然后再计算dp。

下面是具体的Python代码实现：

```python
class Solution:
    def mctFromLeafValues(self, arr: List[int]) -> int:
        # 计算数组长度
        n = len(arr)
        # 初始化动态规划数组dp，dp[i][j]代表子数组arr[i...j]所构成的树中所有非叶节点的最小总和
        dp = [[float('inf')]*n for _ in range(n)]
        # 初始化最大值数组max_arr，max_arr[i][j]代表子数组arr[i...j]中的最大值
        max_arr = [[0]*n for _ in range(n)]
        # 单独处理dp和max_arr的对角线元素
        for i in range(n):
            dp[i][i] = 0
            max_arr[i][i] = arr[i]
        # 遍历所有可能的子数组长度
        for length in range(2, n+1):
            # 对于给定的子数组长度，遍历所有可能的子数组起始位置
            for i in range(n-length+1):
                # 计算子数组的结束位置
                j = i + length - 1
                # 遍历所有可能的分割位置，计算dp[i][j]和max_arr[i][j]
                for k in range(i, j):
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + max_arr[i][k]*max_arr[k+1][j])
                max_arr[i][j] = max(max_arr[i][j-1], arr[j])
        # 返回整个数组的非叶节点的最小总和
        return dp[0][n-1]

```

这段代码中，我们用了两个二维数组dp和max_arr来记录每一个区间的非叶节点的最小总和和最大值。我们用了三层循环，分别表示区间的长度、区间的起始位置和分割的位置。我们在每个区间内尝试所有可能的分割位置，然后更新dp[i][j]和max_arr[i][j]。最后我们返回的就是整个数组的非叶节点的最小总和dp[0][n-1]。

**优化：**

对于本题，我们可以构造一个单调递减的栈。遍历输入的数组，如果栈顶元素比当前元素小，那么就将栈顶元素弹出，将其与栈顶的新元素（即弹出元素的下一个元素）以及当前元素中较小的一个进行乘积操作，并将结果累加到答案中。然后将当前元素压入栈中。

这样做的原因是，如果一个元素在数组中的左右都有比它大的元素，那么它一定会作为左右两边较小的元素与它自身的乘积先被取出。这样我们就可以保证每次取出的都是当前最小的非叶节点。

代码如下：

```python
class Solution:
    def mctFromLeafValues(self, arr: List[int]) -> int:
        # 创建一个单调递减栈，并初始化一个最大值
        stack = [float('inf')]
        # 初始化结果为0
        res = 0
        # 遍历输入的数组
        for num in arr:
            # 如果栈顶元素小于或等于当前元素，就将栈顶元素弹出并计算乘积
            while stack[-1] <= num:
                mid = stack.pop()
                res += mid * min(stack[-1], num)
            # 将当前元素压入栈中
            stack.append(num)
        # 遍历完数组后，如果栈中还有多于一个元素（除了哨兵之外），就继续弹出元素并计算乘积
        while len(stack) > 2:
            res += stack.pop() * stack[-1]
        # 返回累加的结果
        return res

```

这段代码中，我们首先将无穷大压入栈中作为哨兵，然后遍历数组。如果栈顶元素小于或等于当前元素，就将栈顶元素弹出并计算乘积，然后将当前元素压入栈中。遍历完数组后，如果栈中还有多于一个元素（除了哨兵之外），就继续弹出元素并计算乘积，直到栈中只剩下一个元素（哨兵）。最后返回累加的结果即可。