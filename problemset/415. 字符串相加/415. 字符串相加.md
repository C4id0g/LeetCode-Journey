#### [415. 字符串相加](https://leetcode.cn/problems/add-strings/)

难度简单

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。

**示例 1：**

**输入：**num1 = "11", num2 = "123"
**输出：**"134"

**示例 2：**

**输入：**num1 = "456", num2 = "77"
**输出：**"533"

**示例 3：**

**输入：**num1 = "0", num2 = "0"
**输出：**"0"

**提示：**

- `1 <= num1.length, num2.length <= 104`
- `num1` 和`num2` 都只包含数字 `0-9`
- `num1` 和`num2` 都不包含任何前导零

这个题目可以用模拟大数加法的方式来解决。即：从每个数字的最后一位（个位）开始加，如果有进位则记录下来，并在下一轮加上进位。

具体步骤如下：

1. 初始化两个指针分别指向 num1 和 num2 的末尾，从右向左遍历每一位数字，同时初始化一个变量 carry 来记录进位。

2. 当某一位的数字存在时，将其与 carry 相加。

3. 当两个数字的长度不等时，可以在短的数字前面补零，使得两个数字长度一致，这样就可以一一对应的进行加法运算。

4. 当遍历到最后一位数字时，如果还有进位，则再补上一位。

5. 最后，将结果反转并返回。

下面是对应的 Python 代码： 

```python
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        i, j, carry, res = len(num1) - 1, len(num2) - 1, 0, []
        while i >= 0 or j >= 0 or carry:
            n1 = int(num1[i]) if i >= 0 else 0
            n2 = int(num2[j]) if j >= 0 else 0
            tmp = n1 + n2 + carry
            carry = tmp // 10
            res.append(tmp % 10)
            i, j = i - 1, j - 1
        return ''.join(str(x) for x in res[::-1])
```

这段代码的时间复杂度和空间复杂度都是 O(n)，其中 n 是两个输入数字的最大长度。

在这段代码中，我们使用了一个列表 res 来临时存储每一位的结果，并在最后将其转换为字符串。虽然 Python 的字符串是不可变的，但我们可以先使用列表来存储每一位的结果，然后在最后再将其转换为字符串，这样可以避免在每一步都创建一个新的字符串，从而提高效率。