#### [面试题 16.19. 水域大小](https://leetcode.cn/problems/pond-sizes-lcci/)

难度中等

你有一个用于表示一片土地的整数矩阵`land`，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。

**示例：**

**输入：**
[
 [0,2,1,0],
 [0,1,0,1],
 [1,1,0,1],
 [0,1,0,1]
]
**输出：** [1,2,4]

**提示：**

- `0 < len(land) <= 1000`
- `0 < len(land[i]) <= 1000`

这是一道使用深度优先搜索（DFS）算法的题目，可以用Python来实现。DFS的思想是从一个节点开始，沿着一条路径不断探索，直到遇到死胡同或者目标节点，然后回溯到上一个分叉点，继续探索其他路径，直到遍历完所有可能的路径。

为了实现DFS，我们需要用一个栈来存储当前节点的邻居节点，以及一个集合来记录已经访问过的节点。我们从任意一个水域（值为0）的节点开始，将其入栈，并将其加入集合。然后我们不断重复以下步骤：

- 如果栈为空，说明当前路径已经探索完毕，返回。
- 如果栈不为空，弹出栈顶元素，记为当前节点。
- 如果当前节点是水域（值为0），则将其值改为-1，表示已经探索过，并将其周围的八个方向的邻居节点（如果在矩阵范围内且没有被访问过）入栈，并加入集合。
- 如果当前节点不是水域（值不为0），则跳过。

这样，当我们遍历完一个水域时，我们就可以得到它的大小，即值为-1的节点的个数。我们可以用一个计数器来记录这个值，并将其加入到一个结果列表中。然后我们在矩阵中寻找下一个未被访问过的水域，重复上述过程，直到遍历完整个矩阵。最后我们对结果列表进行排序，就得到了所有池塘的大小。

以下是Python代码的实现：

```python
class Solution:
    def pondSizes(self, land: List[List[int]]) -> List[int]:
        # 定义八个方向
        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        # 定义矩阵的行数和列数
        m = len(land)
        n = len(land[0])
        # 定义栈和集合
        stack = []
        visited = set()
        # 定义结果列表
        result = []
        # 遍历矩阵中的每个元素
        for i in range(m):
            for j in range(n):
                # 如果当前元素是水域且未被访问过
                if land[i][j] == 0 and (i, j) not in visited:
                    # 将其入栈并加入集合
                    stack.append((i, j))
                    visited.add((i, j))
                    # 定义计数器
                    count = 0
                    # 开始DFS
                    while stack:
                        # 弹出栈顶元素
                        x, y = stack.pop()
                        # 如果是水域
                        if land[x][y] == 0:
                            # 将其值改为-1，并计数加一
                            land[x][y] = -1
                            count += 1
                            # 遍历八个方向的邻居节点
                            for dx, dy in directions:
                                # 计算邻居节点的坐标
                                nx = x + dx
                                ny = y + dy
                                # 如果邻居节点在矩阵范围内且未被访问过
                                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:
                                    # 将其入栈并加入集合
                                    stack.append((nx, ny))
                                    visited.add((nx, ny))
                    # 结束DFS，将计数器的值加入结果列表
                    result.append(count)
        # 对结果列表进行排序
        result.sort()
        # 返回结果列表
        return result
```